import torch
from sentence_transformers import SentenceTransformer
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from model import FuzeUserEducationIssue  # assuming your SQLAlchemy model is in model.py

# ---------- CONFIG ----------
DATABASE_URL = "postgresql://username:password@localhost/dbname"  # update this
TOP_N = 3
# ----------------------------

# Load model for semantic embeddings
model = SentenceTransformer('all-MiniLM-L6-v2')

# Connect to DB and fetch issues
engine = create_engine(DATABASE_URL)
Session = sessionmaker(bind=engine)
session = Session()
issues = session.query(FuzeUserEducationIssue).all()
session.close()

def score_match(description: str, keywords: list[str]) -> float:
    description = description.lower()
    desc_emb = model.encode(description, convert_to_tensor=True)

    exact_matches = 0
    semantic_scores = []

    for kw in keywords:
        kw = kw.lower()
        if kw in description:
            exact_matches += 1
            semantic_scores.append(1.0)  # perfect match
        else:
            kw_emb = model.encode(kw, convert_to_tensor=True)
            sim = torch.nn.functional.cosine_similarity(desc_emb, kw_emb, dim=0).item()
            semantic_scores.append(sim)

    if not keywords:
        return 0.0

    # Scoring formula:
    exact_score = exact_matches / len(keywords)
    avg_semantic_score = sum(semantic_scores) / len(semantic_scores)
    final_score = 0.5 * exact_score + 0.5 * avg_semantic_score
    return round(final_score, 4)

def find_top_matches(description: str):
    results = []

    for issue in issues:
        keywords = issue.keywords or []
        score = score_match(description, keywords)
        results.append({
            'issue_id': issue.issue_id,
            'issue_name': issue.issue_name,
            'module': issue.module,
            'score': score
        })

    # Sort and return top N
    results.sort(key=lambda x: x['score'], reverse=True)
    return results[:TOP_N]

# ----------- Example Usage -----------
if __name__ == "__main__":
    ticket = {
        "description": "Please change the budget code for this report"
    }

    top_matches = find_top_matches(ticket['description'])
    for match in top_matches:
        print(f"Issue ID: {match['issue_id']} | Score: {match['score']}")
        print(f"  Name: {match['issue_name']} | Module: {match['module']}")
