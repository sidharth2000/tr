def insert_into_nested_dict(root, path_parts):
    if not path_parts:
        return
    
    part = path_parts[0]
    if part not in root:
        root[part] = {}
    
    insert_into_nested_dict(root[part], path_parts[1:])

def build_nested_structure(package_list):
    root = {}
    for package in package_list:
        path_parts = package['package'].split('\\')
        insert_into_nested_dict(root, path_parts)
    return root




def find_and_group_java_files(root_path):
    grouped_files = {}
    for dirpath, dirnames, filenames in os.walk(root_path):
        for filename in filenames:
            if filename.endswith('.java'):
                path = os.path.join(dirpath, filename)
                if 'src\\main\\java' in path:
                    relative_path = path.split('src\\main\\java')[-1].lstrip('\\')
                    directory = os.path.dirname(relative_path)
                    if directory not in grouped_files:
                        grouped_files[directory] = []
                    grouped_files[directory].append(os.path.basename(relative_path))
                elif 'src/main/java' in path:
                    relative_path = path.split('src/main/java')[-1].lstrip('/')
                    directory = os.path.dirname(relative_path)
                    if directory not in grouped_files:
                        grouped_files[directory] = []
                    grouped_files[directory].append(os.path.basename(relative_path))
    
    # Convert the grouped_files dictionary to a list of dictionaries
    grouped_files_list = [{"package": key} for key, value in grouped_files.items()]
    
    return grouped_files_list



def replace_table_with_df(doc, table_index, df):
    # Access the table in the document
    table = doc.tables[table_index]
    font = table.style.font
    font.name = FONT_NAME 
    font.size = Pt(11)
    list_term=[]
    for i, row in df.iterrows():   
        for j,value in enumerate(row):
            # table_row = table.add_row().cells   
            m=1
            
           

            for keys in value: 
                if m==1 and value[keys] in list_term:
                    break 
                # table_row[m].text = value[keys] 
                if m==1:
                    table_row = table.add_row().cells   
                    # m=1
                    # table_row[0].text = str(j+1)
                    cell_paragraph1 = table_row[0].add_paragraph(str(j+1))
                    cell_paragraph1.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                    cell_run1 = cell_paragraph1.runs[0]
                    cell_run1.font.name = FONT_NAME
                    cell_run1.font.size = Pt(11)
                    cell_run1._element.rPr.rFonts.set(qn('w:eastAsia'), FONT_NAME)
                    list_term.append(value[keys])
                    
                cell_text = value[keys]
                
                cell_paragraph = table_row[m].add_paragraph(cell_text)
                cell_paragraph.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
                cell_run = cell_paragraph.runs[0]
                cell_run.font.name = FONT_NAME
                cell_run.font.size = Pt(11)
                cell_run._element.rPr.rFonts.set(qn('w:eastAsia'), FONT_NAME)
                m+=1 
    tblBorders = OxmlElement('w:tblBorders')
    for border_type in ['top', 'left', 'bottom', 'right', 'insideH', 'insideV']:
        border = OxmlElement(f'w:{border_type}')
        border.set('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}val', 'single')  # Set border style to single
        border.set('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}sz', '4')  # Set border size to 4 half-points (2 points)
        tblBorders.append(border)
    tblProperties = table._element.find('w:tblPr', namespaces=table._element.nsmap)
    tblProperties.append(tblBorders)



def terminologiesGeneration(doc,application_name,application_description):

    # Section 2 
    # sec2_prompt="Draft the Terminologies section of the software design document for the given application. This section should include all relevant abbreviations and acronyms. give the description for each abbreviation in json format\n Application context:{app_context}".format(app_context=application_description)
    terminologies_prompt="""Draft the abbreviations section of the software design document for the given application. This section should include only the abbreviations present in the application context given.Strictly don't repeat the same abbreviations in the response. \n Application context:{app_context}
    
    For each abbreviation it should be in format with only abbreviation and it's expansion as [Abbreviation:abbreviation , Expansion : expansion]. Give the valid json as the response.
   
    Note to be considered while response generation: Strictly make sure the resultant json is valid and there is no comma(,) before '}}' in json and ] in list of pseudo code.
    "When working with JSON data, strictly ensure it follows these guidelines to avoid parsing errors:",
    "1. Property Names Enclosed in Double Quotes: Ensure all property names (keys) are enclosed in double quotes (\")."
    "2. No Trailing Commas: Remove any trailing commas at the end of arrays or objects."
    "3. Valid Array and Object Syntax: Ensure arrays and objects are properly formatted with opening and closing brackets or braces."
    "4. Use Valid Data Types: Ensure values in the JSON data are of valid data types (strings, numbers, booleans, arrays, objects, or null).""".format(app_context=application_description)
    
    terminlogies_response=make_completion_gpt4(terminologies_prompt)
   
    
    try:
        terminlogies_response=json.loads(str(terminlogies_response))
        
    except json.JSONDecodeError as e:
        corrected_json_string = re.sub(r',\s*}', '}', terminlogies_response)
        terminlogies_response=json.loads(corrected_json_string)
    # writeoncsv(csvpath,"Terminologies",str(terminlogies_response))
    df1 = pd.DataFrame.from_dict(terminlogies_response, orient='index')
    replace_table_with_df(doc, 1, df1)



=IF(COUNTIF(B:B, A2) = 0, "Not in B", "")


"introduction": This key should contain the introduction section, covering the application overview, current state, goals and objectives, stakeholders and audience, and any other relevant information all together in short paragraph.
    
    2. "purposeAndScope": This key should contain the purpose of the application, the scope and boundaries, assumptions and dependencies, and the document organization all together in short paragraph.

